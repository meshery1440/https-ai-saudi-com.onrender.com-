<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>الذكاء الاصطناعي التوليدي | الذكاء الاصطناعي</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            background: #0a0a1a;
            color: #fff;
            font-family: 'Tajawal', Arial, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 40px auto;
            background: #18182a;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            padding: 2.5rem 2rem;
        }
        .feature-image {
            width: 100%;
            height: 180px;
            background: linear-gradient(45deg, #ff4d8d22, #00f7ff22);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1.5rem;
        }
        .feature-image i {
            font-size: 4rem;
            color: #ff4d8d;
        }
        .title {
            color: #ff4d8d;
            font-size: 2.2rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        .tech-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1.5rem 0 1rem 0;
            justify-content: center;
        }
        .tech-tag {
            background: rgba(255, 77, 141, 0.1);
            color: #ff4d8d;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.95rem;
        }
        .section {
            margin-bottom: 1.7rem;
        }
        .section h2 {
            color: #00f7ff;
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
        }
        ul {
            padding-right: 1.5rem;
        }
        li {
            margin-bottom: 0.5rem;
        }
        .back {
            display: inline-block;
            margin-top: 2rem;
            color: #ff4d8d;
            background: transparent;
            border: 1px solid #ff4d8d;
            padding: 0.5rem 1.5rem;
            border-radius: 30px;
            text-decoration: none;
            font-weight: 600;
            transition: background 0.2s, color 0.2s;
        }
        .back:hover {
            background: #ff4d8d;
            color: #18182a;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="feature-image">
            <i class="fas fa-magic"></i>
        </div>
        
        <div class="interactive-model" style="margin-bottom: 1.5rem; text-align: center;">
            <div id="3d-model-container" style="width: 100%; height: 300px; border-radius: 12px; background: linear-gradient(45deg, #ff4d8d22, #00f7ff22);"></div>
        </div>
        
        <div class="title">الذكاء الاصطناعي التوليدي</div>
        <div class="tech-tags">
            <span class="tech-tag">Generative AI</span>
            <span class="tech-tag">GPT-4</span>
            <span class="tech-tag">DALL-E</span>
            <span class="tech-tag">Stable Diffusion</span>
            <span class="tech-tag">Content Creation</span>
        </div>
        <div class="section">
            <h2>ما هو الذكاء الاصطناعي التوليدي؟</h2>
            <p>الذكاء الاصطناعي التوليدي هو فرع متقدم من الذكاء الاصطناعي يركز على إنشاء محتوى جديد وإبداعي مثل النصوص، الصور، الموسيقى، وحتى الفيديوهات. يستخدم هذا النوع من الذكاء الاصطناعي نماذج متطورة قادرة على فهم الأنماط وتوليد بيانات جديدة تحاكي الإبداع البشري.</p>
        </div>
        <div class="section">
            <h2>تطبيقات الذكاء الاصطناعي التوليدي</h2>
            <p>تُستخدم تقنيات الذكاء الاصطناعي التوليدي في مجالات متعددة، مثل:</p>
            <ul>
                <li>توليد النصوص الإبداعية والمقالات (مثل GPT-4)</li>
                <li>إنشاء صور فنية وواقعية من وصف نصي (مثل DALL-E وStable Diffusion)</li>
                <li>تصميم الموسيقى والمؤثرات الصوتية</li>
                <li>إنتاج فيديوهات ورسوم متحركة تلقائياً</li>
                <li>تحسين عمليات التصميم والإبداع في التسويق والإعلان</li>
            </ul>
        </div>
        <div class="section">
            <h2>الخوارزميات والتقنيات المستخدمة</h2>
            <ul>
                <li><strong>نماذج اللغة الكبيرة (Large Language Models):</strong> مثل GPT-4، لتوليد نصوص عالية الجودة وفهم السياق.</li>
                <li><strong>النماذج التوليدية للصور:</strong> مثل DALL-E وStable Diffusion، لتحويل الأوصاف النصية إلى صور مبتكرة.</li>
                <li><strong>الشبكات التوليدية التنافسية (GANs):</strong> لإنشاء صور وفيديوهات واقعية.</li>
                <li><strong>نماذج التحويل (Transformers):</strong> لبناء أنظمة ذكية قادرة على فهم وتوليد بيانات معقدة.</li>
            </ul>
        </div>
        <div class="section">
            <h2>مستقبل الذكاء الاصطناعي التوليدي</h2>
            <p>سيستمر الذكاء الاصطناعي التوليدي في التطور ليصبح أكثر إبداعًا وقدرة على فهم احتياجات المستخدمين. من المتوقع أن نرى أدوات قادرة على توليد محتوى مخصص بالكامل، وتحسين عمليات الإنتاج الفني والإعلامي، وحتى المشاركة في الابتكار العلمي والتقني.</p>
        </div>
        <a class="back" href="index.html">&#8592; العودة للصفحة الرئيسية</a>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // إعداد المشهد الثلاثي الأبعاد للذكاء الاصطناعي التوليدي
        const container = document.getElementById('3d-model-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setClearColor(0x000000, 0);
        container.appendChild(renderer.domElement);
        
        // إضافة إضاءة
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xff4d8d, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // مجموعة للأشكال المولدة
        const generativeGroup = new THREE.Group();
        
        // إنشاء مجموعة من الجسيمات التي ستمثل المحتوى المولد
        const particlesCount = 1000;
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesMaterial = new THREE.PointsMaterial({
            color: 0xff4d8d,
            size: 0.1,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });
        
        // إنشاء مواقع الجسيمات
        const positions = new Float32Array(particlesCount * 3);
        const colors = new Float32Array(particlesCount * 3);
        const sizes = new Float32Array(particlesCount);
        
        // الألوان المستخدمة في الجسيمات
        const colorOptions = [
            new THREE.Color(0xff4d8d), // وردي
            new THREE.Color(0x00f7ff), // أزرق فاتح
            new THREE.Color(0x6c63ff), // أرجواني
            new THREE.Color(0xffeb3b)  // أصفر
        ];
        
        // توزيع الجسيمات في شكل سحابة
        for (let i = 0; i < particlesCount; i++) {
            // توزيع الجسيمات في شكل كروي
            const radius = 3 + Math.random() * 2;
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI;
            
            positions[i * 3] = radius * Math.sin(theta) * Math.cos(phi);
            positions[i * 3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
            positions[i * 3 + 2] = radius * Math.cos(theta);
            
            // اختيار لون عشوائي من الألوان المتاحة
            const color = colorOptions[Math.floor(Math.random() * colorOptions.length)];
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
            
            // تحديد حجم عشوائي للجسيم
            sizes[i] = Math.random() * 0.2 + 0.05;
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        // تفعيل الألوان المخصصة للجسيمات
        particlesMaterial.vertexColors = true;
        
        // إنشاء نظام الجسيمات
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        generativeGroup.add(particles);
        
        // إنشاء مركز للنموذج التوليدي
        const coreGeometry = new THREE.IcosahedronGeometry(1, 1);
        const coreMaterial = new THREE.MeshPhongMaterial({
            color: 0xff4d8d,
            emissive: 0xff4d8d,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8,
            wireframe: true
        });
        
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        generativeGroup.add(core);
        
        // إنشاء الأشكال المولدة التي تظهر من المركز
        const generatedShapes = [];
        
        // إنشاء أشكال مختلفة لتمثيل المحتوى المولد
        const shapeTypes = [
            new THREE.BoxGeometry(0.5, 0.5, 0.5),
            new THREE.SphereGeometry(0.3, 16, 16),
            new THREE.TorusGeometry(0.3, 0.1, 16, 32),
            new THREE.TetrahedronGeometry(0.3),
            new THREE.OctahedronGeometry(0.3),
            new THREE.ConeGeometry(0.3, 0.5, 16)
        ];
        
        // إنشاء الأشكال المولدة
        function createGeneratedShape() {
            // اختيار شكل عشوائي
            const shapeIndex = Math.floor(Math.random() * shapeTypes.length);
            const geometry = shapeTypes[shapeIndex];
            
            // اختيار لون عشوائي
            const colorIndex = Math.floor(Math.random() * colorOptions.length);
            const color = colorOptions[colorIndex];
            
            const material = new THREE.MeshPhongMaterial({
                color: color,
                transparent: true,
                opacity: 0.7
            });
            
            const shape = new THREE.Mesh(geometry, material);
            
            // تعيين موقع البداية في المركز
            shape.position.set(0, 0, 0);
            shape.scale.set(0.1, 0.1, 0.1); // يبدأ صغيراً
            
            // تعيين اتجاه عشوائي للحركة
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI;
            
            shape.userData = {
                velocity: new THREE.Vector3(
                    Math.sin(theta) * Math.cos(phi),
                    Math.sin(theta) * Math.sin(phi),
                    Math.cos(theta)
                ).multiplyScalar(0.03),
                rotationSpeed: new THREE.Vector3(
                    Math.random() * 0.05,
                    Math.random() * 0.05,
                    Math.random() * 0.05
                ),
                lifespan: 0,
                maxLifespan: 100 + Math.random() * 50
            };
            
            generativeGroup.add(shape);
            generatedShapes.push(shape);
            
            return shape;
        }
        
        // إنشاء بعض الأشكال المبدئية
        for (let i = 0; i < 5; i++) {
            createGeneratedShape();
        }
        
        // إضافة مجموعة النموذج التوليدي للمشهد
        scene.add(generativeGroup);
        
        // تعيين موضع الكاميرا
        camera.position.z = 8;
        
        // عداد لإنشاء أشكال جديدة
        let counter = 0;
        
        // تحريك النموذج
        function animate() {
            requestAnimationFrame(animate);
            
            // تدوير المجموعة ببطء
            generativeGroup.rotation.y += 0.003;
            
            // تدوير المركز
            core.rotation.x += 0.01;
            core.rotation.y += 0.01;
            
            // تحريك الجسيمات بنمط موجي
            const positions = particlesGeometry.attributes.position.array;
            for (let i = 0; i < particlesCount; i++) {
                const i3 = i * 3;
                const x = positions[i3];
                const y = positions[i3 + 1];
                const z = positions[i3 + 2];
                
                // تطبيق حركة موجية خفيفة
                positions[i3] = x + Math.sin(Date.now() * 0.001 + i * 0.1) * 0.01;
                positions[i3 + 1] = y + Math.cos(Date.now() * 0.001 + i * 0.1) * 0.01;
                positions[i3 + 2] = z + Math.sin(Date.now() * 0.001 + i * 0.05) * 0.01;
            }
            particlesGeometry.attributes.position.needsUpdate = true;
            
            // تحريك الأشكال المولدة
            for (let i = generatedShapes.length - 1; i >= 0; i--) {
                const shape = generatedShapes[i];
                
                // تحريك الشكل بناءً على سرعته
                shape.position.add(shape.userData.velocity);
                
                // تدوير الشكل
                shape.rotation.x += shape.userData.rotationSpeed.x;
                shape.rotation.y += shape.userData.rotationSpeed.y;
                shape.rotation.z += shape.userData.rotationSpeed.z;
                
                // زيادة الحجم تدريجياً في البداية
                if (shape.userData.lifespan < 20) {
                    const scale = Math.min(1, shape.userData.lifespan / 20);
                    shape.scale.set(scale, scale, scale);
                }
                
                // تقليل الشفافية في نهاية العمر
                if (shape.userData.lifespan > shape.userData.maxLifespan - 20) {
                    const opacity = (shape.userData.maxLifespan - shape.userData.lifespan) / 20;
                    shape.material.opacity = opacity;
                }
                
                // زيادة عمر الشكل
                shape.userData.lifespan++;
                
                // إزالة الشكل بعد انتهاء عمره
                if (shape.userData.lifespan >= shape.userData.maxLifespan) {
                    generativeGroup.remove(shape);
                    generatedShapes.splice(i, 1);
                }
            }
            
            // إنشاء شكل جديد كل فترة
            counter++;
            if (counter >= 30) { // إنشاء شكل جديد كل 30 إطار
                createGeneratedShape();
                counter = 0;
            }
            
            renderer.render(scene, camera);
        }
        
        // معالجة تغيير حجم النافذة
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        animate();
    </script>
</body>
</html>
