<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>الشبكات العصبية | الذكاء الاصطناعي</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            background: #0a0a1a;
            color: #fff;
            font-family: 'Tajawal', Arial, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 40px auto;
            background: #18182a;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            padding: 2.5rem 2rem;
        }
        .feature-image {
            width: 100%;
            height: 180px;
            background: linear-gradient(45deg, #00f7ff22, #ff408122);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1.5rem;
        }
        .feature-image i {
            font-size: 4rem;
            color: #00f7ff;
        }
        .title {
            color: #00f7ff;
            font-size: 2.2rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        .tech-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1.5rem 0 1rem 0;
            justify-content: center;
        }
        .tech-tag {
            background: rgba(0, 247, 255, 0.1);
            color: #00f7ff;
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            font-size: 0.95rem;
        }
        .section {
            margin-bottom: 1.7rem;
        }
        .section h2 {
            color: #ff4081;
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
        }
        ul {
            padding-right: 1.5rem;
        }
        li {
            margin-bottom: 0.5rem;
        }
        .back {
            display: inline-block;
            margin-top: 2rem;
            color: #00f7ff;
            background: transparent;
            border: 1px solid #00f7ff;
            padding: 0.5rem 1.5rem;
            border-radius: 30px;
            text-decoration: none;
            font-weight: 600;
            transition: background 0.2s, color 0.2s;
        }
        .back:hover {
            background: #00f7ff;
            color: #18182a;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="feature-image">
            <i class="fas fa-project-diagram"></i>
        </div>
        
        <div class="interactive-model" style="margin-bottom: 1.5rem; text-align: center;">
            <div id="3d-model-container" style="width: 100%; height: 300px; border-radius: 12px; background: linear-gradient(45deg, #00f7ff22, #ff408122);"></div>
        </div>
        
        <div class="title">الشبكات العصبية</div>
        <div class="tech-tags">
            <span class="tech-tag">Neural Networks</span>
            <span class="tech-tag">Deep Learning</span>
            <span class="tech-tag">AI</span>
            <span class="tech-tag">Pattern Recognition</span>
            <span class="tech-tag">Computation</span>
        </div>
        <div class="section">
            <h2>ما هي الشبكات العصبية؟</h2>
            <p>الشبكات العصبية هي نماذج حسابية مستوحاة من طريقة عمل الدماغ البشري، تتكون من وحدات مترابطة (عُقد) تُسمى الخلايا العصبية الاصطناعية. تُستخدم هذه الشبكات في معالجة البيانات، التعرف على الأنماط، واتخاذ القرارات.</p>
        </div>
        <div class="section">
            <h2>تطبيقات الشبكات العصبية</h2>
            <p>تستخدم الشبكات العصبية في مجالات مثل التعرف على الصور، معالجة اللغة الطبيعية، الترجمة الآلية، التنبؤ المالي، وحتى في السيارات ذاتية القيادة.</p>
        </div>
        <div class="section">
            <h2>الخوارزميات والتقنيات المستخدمة</h2>
            <ul>
                <li><strong>الشبكات العصبية التلافيفية (CNN):</strong> لتحليل الصور والتعرف على الأنماط البصرية.</li>
                <li><strong>الشبكات العصبية المتكررة (RNN):</strong> لمعالجة البيانات المتسلسلة مثل النصوص والكلام.</li>
                <li><strong>الشبكات العميقة:</strong> لتعلم التمثيلات المعقدة من البيانات الضخمة.</li>
                <li><strong>التعلم المعزز:</strong> لتحسين اتخاذ القرار في البيئات الديناميكية.</li>
            </ul>
        </div>
        <div class="section">
            <h2>مستقبل الشبكات العصبية</h2>
            <p>مع تطور الذكاء الاصطناعي، ستصبح الشبكات العصبية أكثر تعقيدًا وفعالية، مما يسمح بحل مشاكل أكثر تعقيدًا في مجالات متعددة. من المتوقع أن نشهد تطورات في الشبكات العصبية التوليدية والشبكات ذاتية التنظيم.</p>
        </div>
        <a class="back" href="index.html">&#8592; العودة للصفحة الرئيسية</a>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // إعداد المشهد الثلاثي الأبعاد للشبكات العصبية
        const container = document.getElementById('3d-model-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setClearColor(0x000000, 0);
        container.appendChild(renderer.domElement);
        
        // إضافة إضاءة
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0x00f7ff, 1);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        
        // إنشاء نموذج الشبكة العصبية
        const networkGroup = new THREE.Group();
        
        // إنشاء الطبقات
        const layers = [
            { nodes: 4, position: -5 },  // طبقة الإدخال
            { nodes: 6, position: -2.5 }, // طبقة مخفية 1
            { nodes: 6, position: 0 },    // طبقة مخفية 2
            { nodes: 4, position: 2.5 },  // طبقة مخفية 3
            { nodes: 2, position: 5 }     // طبقة الإخراج
        ];
        
        // إنشاء العقد والروابط
        const nodes = [];
        const nodeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        
        // إنشاء العقد لكل طبقة
        layers.forEach((layer, layerIndex) => {
            const layerNodes = [];
            
            // إنشاء العقد في الطبقة
            for (let i = 0; i < layer.nodes; i++) {
                // توزيع العقد عمودياً
                const yPos = (i - (layer.nodes - 1) / 2) * 1.2;
                
                // اختيار لون مختلف لكل طبقة
                let nodeColor;
                if (layerIndex === 0) {
                    nodeColor = 0x00f7ff; // طبقة الإدخال
                } else if (layerIndex === layers.length - 1) {
                    nodeColor = 0xff4081; // طبقة الإخراج
                } else {
                    nodeColor = 0x6c63ff; // الطبقات المخفية
                }
                
                const nodeMaterial = new THREE.MeshPhongMaterial({
                    color: nodeColor,
                    emissive: nodeColor,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0.8
                });
                
                const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                node.position.set(layer.position, yPos, 0);
                networkGroup.add(node);
                
                layerNodes.push(node);
            }
            
            nodes.push(layerNodes);
        });
        
        // إنشاء الروابط بين العقد
        for (let i = 0; i < nodes.length - 1; i++) {
            const currentLayer = nodes[i];
            const nextLayer = nodes[i + 1];
            
            // ربط كل عقدة في الطبقة الحالية بكل عقدة في الطبقة التالية
            currentLayer.forEach(currentNode => {
                nextLayer.forEach(nextNode => {
                    // إنشاء خط للربط
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x444444,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const points = [];
                    points.push(currentNode.position.clone());
                    points.push(nextNode.position.clone());
                    
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    networkGroup.add(line);
                });
            });
        }
        
        // إضافة مجموعة الشبكة للمشهد
        scene.add(networkGroup);
        
        // إضافة تأثير النبضات للشبكة
        const pulses = [];
        
        function createPulse() {
            // اختيار عقدة عشوائية من طبقة الإدخال
            const startNodeIndex = Math.floor(Math.random() * nodes[0].length);
            const startNode = nodes[0][startNodeIndex];
            
            // إنشاء كرة صغيرة لتمثيل النبضة
            const pulseGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const pulseMaterial = new THREE.MeshPhongMaterial({
                color: 0x00f7ff,
                emissive: 0x00f7ff,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.8
            });
            
            const pulse = new THREE.Mesh(pulseGeometry, pulseMaterial);
            pulse.position.copy(startNode.position);
            networkGroup.add(pulse);
            
            // تحديد مسار النبضة عبر الشبكة
            const path = [];
            let currentLayer = 0;
            let currentNode = startNode;
            
            path.push({ position: currentNode.position.clone(), layer: currentLayer });
            
            // إنشاء مسار عبر الطبقات
            while (currentLayer < nodes.length - 1) {
                currentLayer++;
                // اختيار عقدة عشوائية من الطبقة التالية
                const nextNodeIndex = Math.floor(Math.random() * nodes[currentLayer].length);
                currentNode = nodes[currentLayer][nextNodeIndex];
                path.push({ position: currentNode.position.clone(), layer: currentLayer });
            }
            
            pulses.push({ mesh: pulse, path: path, progress: 0, speed: 0.02 });
        }
        
        // إنشاء نبضات مبدئية
        for (let i = 0; i < 3; i++) {
            createPulse();
        }
        
        // تعيين موضع الكاميرا
        camera.position.set(0, 0, 12);
        camera.lookAt(0, 0, 0);
        
        // تحريك النموذج
        function animate() {
            requestAnimationFrame(animate);
            
            // تدوير الشبكة ببطء
            networkGroup.rotation.y += 0.002;
            
            // تحريك النبضات عبر الشبكة
            pulses.forEach((pulse, index) => {
                pulse.progress += pulse.speed;
                
                if (pulse.progress >= pulse.path.length - 1) {
                    // إعادة تعيين النبضة عند وصولها للنهاية
                    networkGroup.remove(pulse.mesh);
                    pulses.splice(index, 1);
                    createPulse();
                    return;
                }
                
                // حساب موقع النبضة بين نقطتين
                const pathIndex = Math.floor(pulse.progress);
                const nextPathIndex = Math.min(pathIndex + 1, pulse.path.length - 1);
                const pathProgress = pulse.progress - pathIndex;
                
                const currentPos = pulse.path[pathIndex].position;
                const nextPos = pulse.path[nextPathIndex].position;
                
                // تحريك النبضة بين النقطتين
                pulse.mesh.position.lerpVectors(currentPos, nextPos, pathProgress);
                
                // تغيير لون النبضة بناءً على الطبقة
                const currentLayer = pulse.path[pathIndex].layer;
                const nextLayer = pulse.path[nextPathIndex].layer;
                const layerProgress = currentLayer === nextLayer ? 0 : pathProgress;
                
                // تحديد اللون بناءً على الطبقة
                let startColor, endColor;
                
                if (currentLayer === 0) {
                    startColor = new THREE.Color(0x00f7ff);
                } else if (currentLayer === nodes.length - 1) {
                    startColor = new THREE.Color(0xff4081);
                } else {
                    startColor = new THREE.Color(0x6c63ff);
                }
                
                if (nextLayer === 0) {
                    endColor = new THREE.Color(0x00f7ff);
                } else if (nextLayer === nodes.length - 1) {
                    endColor = new THREE.Color(0xff4081);
                } else {
                    endColor = new THREE.Color(0x6c63ff);
                }
                
                const color = new THREE.Color().lerpColors(startColor, endColor, layerProgress);
                pulse.mesh.material.color.set(color);
                pulse.mesh.material.emissive.set(color);
            });
            
            renderer.render(scene, camera);
        }
        
        // معالجة تغيير حجم النافذة
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        animate();
    </script>
</body>
</html>
